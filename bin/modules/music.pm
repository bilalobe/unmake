package music; # Declare the package name

use strict;
use warnings;
use Exporter 'import';
use MIDI::Util;
use MIDI::Opus; 

# Export the functions you want to use in your main script
our @EXPORT = qw(compose_midi extract_elements map_elements_to_music generate_midi_music); 

# Configuration for MIDI output 
my $default_tempo = 120;  
my $default_key = 'C major';  
my $output_midi_file = 'unmake_symphony.mid';

# Function to compose the MIDI music
sub compose_midi {
    my ($theme) = @_; # Get the selected theme

    my $code = get_script_code(); 
    my ($functions, $keywords) = extract_elements($code);

    my $elements = { function => $functions, keyword => $keywords };
    my $mapped_notes = map_elements_to_music($elements, $theme);
    generate_midi_music($mapped_notes, $output_midi_file); 
}

# Function to extract key elements from the Perl script
sub extract_elements {
    my ($code) = @_;

    # Use regular expressions to extract functions and keywords
    my @functions = $code =~ /sub\s+(\w+)/g;
    my @keywords = $code =~ /\b(if|else|elsif|while|for|foreach|return|print|use|my)\b/g;

    return (\@functions, \@keywords);
}

# Function to map code elements to MIDI notes
sub map_elements_to_music {
    my ($elements, $theme) = @_;

    my %note_map = (
        default => { 
            function => [60, 62, 64, 65, 67], # MIDI note numbers (C4, D4, E4, F4, G4)
            keyword => [67, 69, 71, 72, 74]   # MIDI note numbers (G4, A4, B4, C5, D5)
        },
        epic => { 
            function => [48, 50, 52, 53, 55], # Lower notes for an epic feel
            keyword => [55, 57, 59, 60, 62]
        },
        mysterious => { 
            function => [72, 74, 76, 77, 79], # Higher notes for a mysterious feel
            keyword => [79, 81, 83, 84, 86]
        },
    );

    # ... (Add more themes if needed)

    my %mapped_notes;

    for my $type (qw(function keyword)) {
        my @notes = @{$note_map{$theme}{$type}};
        for my $element (@{$elements->{$type}}) {
            push @{$mapped_notes{$type}}, $notes[scalar @{$mapped_notes{$type}} % @notes];
        }
    }

    return \%mapped_notes;
}

# Function to generate the MIDI music
sub generate_midi_music {
    my ($mapped_notes, $output_file) = @_;

    # Create a new MIDI Opus object
    my $opus = MIDI::Opus->new({
        'format' => 1,  # Format 1 MIDI file
        'ticks'  => 96,  # Ticks per quarter note (resolution)
        'tracks' => [
            MIDI::Track->new({
                'events' => [
                    ['text_event', 0, 'Generated by Unmake.pl'],
                    ['time_signature', 0, 4, 2, 24, 8], 
                    ['key_signature', 0, 0, 0], 
                    ['set_tempo', 0, 500000],  # Set tempo (microseconds per quarter note)
                ]
            }),
            MIDI::Track->new({
                'type' => 'MIDI::Track',
                'events' => [
                    # Add note events for functions
                    (map { 
                        ['note_on', 0, $_, 100], ['note_off', 96, $_, 100] 
                    } @{$mapped_notes->{function}}),
                    # Add note events for keywords
                    (map { 
                        ['note_on', 0, $_, 100], ['note_off', 48, $_, 100] 
                    } @{$mapped_notes->{keyword}})
                ]
            })
        ]
    });

    $opus->write_to_file($output_file);
}

sub get_script_code {
    # ... (Implement logic to read the contents of the main script file (unmake.pl) )
}

1; # Return true to indicate successful module loading